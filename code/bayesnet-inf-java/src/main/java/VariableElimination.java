import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import static java.util.stream.Collectors.toList;

/**
 * Implements Variable Elimination.
 *
 * @author rliu 03/22
 */
public class VariableElimination {

    /**
     * The effective treewidth is defined as the treewidth of the *pruned* graph.
     * The graph is left unmodified.
     */
    public static Map<List<DiscreteVariable>, Integer> computeEffectiveTreeWidths(Graph g, Probability query) {
        Graph g2 = GraphUtils.deepCopyGraph(g);
        pruneNetwork(g2, query);
        return computeTreeWidths(g2);
    }

    /**
     * The treewidth is the width of the best variable elimination order obtainable from the graph. The treewidth can
     * never be lower than the number of parents a node has; so the worst-case number of parents (max number of parents
     * of a node) provides a lower-bound for the treewidth. The max treewidth can be computed (inefficiently) by
     * brute-force by simulating all possible variable orders. This function does this.
     *
     * Returns a mpa of every variable order to the treewidth. The map is sorted by values in ascension.
     */
    public static Map<List<DiscreteVariable>, Integer> computeTreeWidths(Graph g) {
        List<DiscreteVariable> elim_vars = new ArrayList<>(g.getNodes().stream().map(Node::getVar).toList());
        List<List<Integer>> seqs = new ArrayList<>();
        ListUtils.permute(new int[elim_vars.size()], 0, seqs, elim_vars.size()-1);
        // Filter out sequences with repeated elements:
        seqs = seqs.stream().filter(seq -> new HashSet<>(seq).size() == seq.size()).toList();

        List<List<DiscreteVariable>> seqs_vars = seqs.stream().map(lst -> lst.stream().map(elim_vars::get).toList()).toList();

        Map<List<DiscreteVariable>, Integer> ve_widths_map = new LinkedHashMap<>();
        for (List<DiscreteVariable> seq : seqs_vars) {
            ve_widths_map.put(seq, getWidthOfSimVETrace(SimVE(g, seq)));
        }

        return ve_widths_map.entrySet()
            .stream()
            .sorted((e1,e2) -> Integer.compare(e1.getValue(), e2.getValue()))
            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));
    }

    /**
     * Pruning network based on Q, e. See page 143.
     * Modifies the input graph {@code g} directly. To keep the input graph, make a deepCopy of it using {@code GraphUtils.deepCopy(g)}.
     */
    public static void pruneNetwork(Graph g, Probability query) {
        // qe is the set (Q union E); therefore include instances' as well.
        List<DiscreteVariable> qe = new ArrayList<>(query.getVars());
        qe.addAll(query.getInstsAsVars());

        // 1. Iteratively prune leaf nodes not in Q union E until there are no more leaf nodes not in Q union E.
        Set<Node> nodes = g.getNodes();
        int num_pruned = -1;
        List<Node> to_remove = new ArrayList<>();
        while (num_pruned != 0) {
            num_pruned = 0;
            to_remove.clear();
            for (Node n : nodes) {
                if (n.getChildren().size() == 0 && !qe.contains(n.getVar())) {
                    to_remove.add(n);
                    num_pruned++;
                }
            }
            to_remove.forEach(nodes::remove);
            to_remove.forEach(_n -> _n.getParents().forEach(_p -> _p.getChildren().remove(_n)));
        }

        // 2. Prune edges
        for (DiscreteVariable.Instance ivar : query.getInsts()) {
            Optional<Node> n_opt = nodes.stream().filter(n -> n.getVar().equals(ivar.parent)).findFirst();
            if (n_opt.isPresent()) {
                Node n = n_opt.get();

                // Children CPTs (X) can be reduced by the evidence at this node n (U)
                for (Node n_ch : n.getChildren()) {
                    Factor n_ch_f2 = FactorOperations.reduce(n_ch.getFactor(), ivar);
                    // After reduction, we can remove the variale altogether from the factor. We will have to remove it
                    // since we will be unlinking it from its parents (so its factor should no longer list its parent var)
                    n_ch_f2 = FactorOperations.sum_out(n_ch_f2, Arrays.asList(ivar.parent));
                    n_ch.setFactor(n_ch_f2);
                }

                // Remove all edges U->X
                n.getChildren().forEach(_c -> _c.getParents().remove(n));
                n.getChildren().clear();
            }
        }
    }

    /**
     * Returns the width of the trace found by SimVE. The input list of factors is the trace generated by SimVE, the
     * factors in the list being the running product factor *before* the sum-out in each iteration.
     */
    public static int getWidthOfSimVETrace(List<Factor> trace) {
        List<List<String>> trace_vars = trace.stream().map(Factor::getVariableNames).toList();
        List<Integer> trace_widths = trace_vars.stream().map(List::size).toList();
        return Collections.max(trace_widths);
    }

    /**
     * Simulates Variable Elimination without actually computing Factor multiplications or sum-outs. The goal is to
     * return a trace that allows you to examine the maximum width of the order.
     * @param g
     * @param ve_order
     * @return a trace of the resulting factor at every iteration of (simulated) VE.
     */
    public static List<Factor> SimVE(Graph g, List<DiscreteVariable> ve_order) {
        if (verifyGraph(g) || verifyVEOrderNames(g, ve_order)) {
            return null;
        }

        List<Factor> factors = g.getNodes().stream().map(Node::getFactor).collect(toList());

        List<Factor> trace = new ArrayList<>();
        List<Factor> trace2 = new ArrayList<>();
        Factor product = null;
        for (DiscreteVariable var : ve_order) {
            List<Factor> relevant = new ArrayList<>();
            for (Factor f : factors) {
                if (f.getVariableNames().contains(var.getName())) {
                    relevant.add(f);
                }
            }
            factors.removeAll(relevant);

            if (product == null)
                product = relevant.remove(0);
            for (Factor f_rel : relevant) {
                product = FactorOperations.fake_multiply(product, f_rel);
            }
            trace.add(product);
            product = FactorOperations.fake_sum_out(product, Arrays.asList(var));
            trace2.add(product);
        }

        return trace;
    }


    /**
     * This VE implements preliminary (aggressive) evidence-reduction. All factors are reduced by the evidence before
     * multiplication.
     * @param g the bayesian network.
     * @param ve_order the variable elimination order desired. If variables are not in the graph, returns null.
     * @param query the probability query.
     * @return a new factor, the product factor; or null if variables in {@code ve_order} or {@code query} are not in the
     * the graph.
     * todo: version of ve using evidence indicators
     * todo: return a list of factors for all the independent factors left over?
     * todo: bucketsort to make looking for the relevant factors more efficient
     */
    public static Factor RunVE(Graph g, List<DiscreteVariable> ve_order, Probability query) {
        if (verifyGraph(g) || verifyVEOrderNames(g, ve_order) || verifyQuery(g, query)) {
            return null;
        }

        List<Factor> factors = g.getNodes().stream().map(Node::getFactor).collect(toList());

        Factor product = null;
        for (DiscreteVariable var : ve_order) {
            List<Factor> relevant = new ArrayList<>();
            for (Factor f : factors) {
                if (f.getVariableNames().contains(var.getName())) {
                    relevant.add(f);
                }
            }
            factors.removeAll(relevant);

            for (Factor f_rel : relevant) {
                for (DiscreteVariable.Instance evidence : query.getInsts()) {
                    f_rel = FactorOperations.reduce(f_rel, evidence); // reduce by the evidence
                }
                if (product == null)
                    product = f_rel;
                else
                    product = FactorOperations.multiply(product, f_rel);
            }
            product = FactorOperations.sum_out(product, Arrays.asList(var));
        }

        // Multiply with all remaining factors
        for (Factor f : factors) {
            product = FactorOperations.multiply(product, f);
        }

        return product;
    }


    /**
     * Verifies the graph for structural consistency of the nodes, and consistency of the factors and the structure.
     */
    private static boolean verifyGraph(Graph g) {
        List<String> problems = new ArrayList<>();
        problems.addAll(GraphVerification.verifyStructure(g));
        problems.addAll(GraphVerification.verifyFactors(g));
        if (problems.size() > 0) {
            System.out.println("The following problems with graph G prevented VE from running:\n" + problems);
            return true;
        }
        return false;
    }

    /**
     * Verifies that the variable names in the ve_order are all in the graph's variables.
     */
    private static boolean verifyVEOrderNames(Graph g, List<DiscreteVariable> ve_order) {
        Set<String> graph_var_names = GraphUtils.getAllVariableNames(g);
        List<String> ve_order_names = ve_order.stream().map(DiscreteVariable::getName).toList();
        if (! graph_var_names.containsAll(ve_order_names)) {
            System.out.println("Graph g does not contain all the variables specified in the VE order: " + ve_order_names);
            return true;
        }
        return false;
    }

    /**
     * Verifies that the variable names in the query are all in the graph's variables.
     */
    private static boolean verifyQuery(Graph g, Probability query) {
        Set<String> graph_var_names = GraphUtils.getAllVariableNames(g);
        Set<String> query_var_names = ProbabilityUtils.getAllVariableNames(query);
        if (! graph_var_names.containsAll(query_var_names)) {
            System.out.println("Graph g does not contain all the variables specified in the Probability query: " + query_var_names);
            return true;
        }
        return false;
    }



}
